## 주기억 장치 관리 개요
### 메모리 역사
- 메모리 역사
	- core memeory
	- 진공관 메모리
	- 트랜지스터 메모리
	- 집적회로 메모리: SRAM, DRAM
- 메모리 용량
	- 1970년대: 8-bit PC 64KB
	- 1980년대: 16-bit IBM-PC 640KB > 1MB > 4MB
	- 1990년: 수 MB > 수십 MB
	- 2000년-: 수백 MB > 수 GB
우리가 쓰는 운영체제는 대부분 60년대에 만들어짐.

### 언제나 부족한 메모리
- 프로그램 변천
	- 기계어/어셈블리어 작성
	- C언어 작성
	- 자바, 객체지향형 언어 작성
	- 숫자 처리 > 문자 처리 > 멀티미디어 처리 > Big Data
- 메모리 용량 증가 vs 프로그램 크기 증가
	- 언제나 부족한 메모리
- 어떻게 메모리를 효과적으로 사용할 수 있을까?
	- 메모리 낭비 없애기
	- 가상 메모리 (virtual memory)

### 프로그램을 메모리에 올리기
- 메모리 구조 
	- 주소(Address) + 데이터(Data)
- 프로그램 개발
	- Source file: 고수준언어 또는 어셈블리언어
	- Object file: 컴파일 또는 어셈블 결과
	- Executable file: 링크 결과
- 컴파일러, 어셈블러, 링커, 로더
- 프로그램 실행: code + data + stack
- 실행파일을 메모리에 올리기
	- 메모리 몇 번지에?
	- 다중 프로그래밍 환경에서는?
- MMU 사용
	- 재배치 레지스터 (Relocation register)
- 주소 구분
	- logical address vs physical address

## 메모리 절약

### 프로그램을 메모리에 올리기
- 실행파일을 메모리에 올리기
	- 메모리 몇 번지에?
	- 다중 프로그래밍 환경에서는?
바깥 영역을 침범하는 프로그램을 강제로 종료
오늘 말하려는 MMU는 또 다른 목적.

### 동적 적재 (Dynamic Loading)
- 프로그램 실행에 반드시 필요한 루틴/데이터만 적재
	- 모든 루틴이 다 사용되는 것은 아니다 (예: 오류처리)
	- 모든 데이터(data)가 다 사용되는 것은 아니다 (예: 배열)
	- 자바: 모든 클래스가 다 사용되는 것은 아니다
	- 실행 시 필요하면 그때 해당 부분을 메모리에 올린다
		- cf. 정적 적재 (Static loading)
현대 운영체제는 대부분 동적 적재. 예전에는 정적 적재를 하는 경우가 많았다.


### 동적 연결 (Dynamic Linking)
- 여러 프로그램에 공통 사용되는 라이브러리
	- 공통 라이브러리 루틴을 메모리에 중복으로 올리는 것은 낭비
	- 라이브러리 루틴 연결을 실행 시까지 미룬다
	- 오직 하나의 라이브러리 루틴만 메모리에 적재되고
	- 다른 애플리케이션 실행 시 이 루틴과 연결된다
	- 공유 라이브러리 (shared library) - Linux 또는
	- 동적 연결 라이브러리 (Dynamic Linking Library) - Windows
확장자 dll은 동적 연결 라이브러리. 연결은 실제 그 프로그램이 실행할 때만 연결되도록 만들어줌.

### Swapping
- 메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스 이미지
	- 메모리 활용도 높이기 위해 Backing store (=swap device)로 몰아내기
	- swap-out vs swap-in
	- Relocation register 사용으로 적재 위치는 무관
	- 프로세스 크기가 크면 backing store 입출력에 따른 부담 크다
